#!/usr/bin/env bash
# Modified from https://github.com/pimterry/notes/blob/master/notes

# Configuration
QUICKNOTE_FORMAT="logs/%Y-%m-W%V"
NOTES_EXT="md"
EDITOR=vim

# Directory where notes are stored
machine="$(uname -s)"
case "${machine}" in
    Linux*)  NOTES_DIRECTORY=/keybase/private/eigenfoo;;
    Darwin*) NOTES_DIRECTORY=/Volumes/Keybase/private/eigenfoo;;
esac

configured_dir=${NOTES_DIRECTORY%/} # Remove trailing slashes
notes_dir="${configured_dir:-$HOME/notes}"
escaped_notes_dir="$(printf "$notes_dir" | sed -e 's/[]\/$*.^|[]/\\&/g')"

without_notes_dir() {
    cat | sed -e "s/^$escaped_notes_dir//g" | sed -E "s/^\/+//g"
}

search_filenames_and_contents() {
    query=$*
    find_notes $query
    grep_notes $query
}

find_notes() {
    find "$notes_dir" -ipath "$notes_dir/*$**" -type f | without_notes_dir
}

grep_notes() {
    grep --color=always -ir "$notes_dir" -e "$*" 2>&1 | without_notes_dir
}

generate_log() {
    local format_string="`date +$QUICKNOTE_FORMAT`"
    printf $format_string
}

log() {
    note_name="$(generate_log)"
    mkdir -p "$(dirname "$notes_dir/$note_name")"
    note_path=$( get_full_note_path "$note_name" )

    if [ ! -f $note_path ]; then
        machine="$(uname -s)"
        case "${machine}" in
            Linux*)  DATE=date;;
            Darwin*) DATE=gdate;;
        esac
        printf "## $($DATE -d 'last sunday + 1 day' +'%A (%Y-%m-%d)')\n\n- \n\n" > $note_path;
        printf "## $($DATE -d 'last sunday + 2 day' +'%A (%Y-%m-%d)')\n\n- \n\n" >> $note_path;
        printf "## $($DATE -d 'last sunday + 3 day' +'%A (%Y-%m-%d)')\n\n- \n\n" >> $note_path;
        printf "## $($DATE -d 'last sunday + 4 day' +'%A (%Y-%m-%d)')\n\n- \n\n" >> $note_path;
        printf "## $($DATE -d 'last sunday + 5 day' +'%A (%Y-%m-%d)')\n\n- \n\n" >> $note_path;
        printf "## $($DATE -d 'last sunday + 6 day' +'%A (%Y-%m-%d)')\n\n- \n\n" >> $note_path;
        printf "## $($DATE -d 'last sunday + 7 day' +'%A (%Y-%m-%d)')\n\n- \n\n" >> $note_path;
    fi
    open_note "$note_name"
}

generate_name() {
    local append_num=0
    local format_string="`date +$QUICKNOTE_FORMAT`"
    # Initial test has no append
    local resolved_name=$format_string
    while [[ -e "$notes_dir/$resolved_name.$NOTES_EXT" ]]
    do
        append_num=$[$append_num+1]
        resolved_name=$format_string.$append_num
    done
    printf $resolved_name
}

new_note() {
    local note_name="$*"
    if [[ $note_name == "" ]]; then
         note_name="$(generate_name)"
    fi

    if echo "$note_name" | grep "/$" &> /dev/null; then
        note_name="${note_name}/$(generate_name)"
    fi

    mkdir -p "$(dirname "$notes_dir/$note_name")"

    open_note "$note_name"
}

handle_multiple_notes() {
    local cmd=$1

    if [[ -p /dev/stdin ]]; then
        read -d'\n' note_names
        while read note_name; do
            ${cmd}_note "$note_name"
        done <<< "$note_names"
    else
        ${cmd}_note "${@:2}"
    fi
}

get_full_note_path() {
    local note_path=$1

    if [[ "$note_path" != *.$NOTES_EXT ]]; then
        note_path="$note_path.$NOTES_EXT"
    fi
    if [ ! -f "$note_path" ]; then
        note_path="$notes_dir/$note_path"
    fi

    echo "$note_path"
}

open_note() {
    local note_path=$1

    if [[ -z "$note_path" ]]; then
        $EDITOR "$notes_dir"
        return
    fi

    note_path=$( get_full_note_path "$note_path" )

    $EDITOR "$note_path" < /dev/tty
}

usage() {
  local name=$(basename $0)
	cat <<EOF
                           ___      ___  _____  ___   
                          |"  \    /"  |(\"   \|"  \  
                           \   \  //   ||.\\   \    | 
                           /\\  \/.    ||: \.   \\  | 
                          |: \.        ||.  \    \. | 
                          |.  \    /:  ||    \    \ | 
                          |___|\__/|___| \___|\____\) 

$name is a command line note taking tool.

Usage:
    $name                       # Open this week's log entry
    $name new|n <name>          # Create a new note
    $name find|f [pattern]      # Find notes by filename and path
    $name grep|g <pattern>      # Grep notes by content
    $name search|s [pattern]    # Search notes by filename and content
    $name open|o                # Open notes directory
    $name open|o <name>         # Open a note for editing by full name
    $name --help                # Print this help message

'command|c' means you can use 'command' or the equivalent shorthand alias 'c'

Your notes directory is $notes_dir.
You can override this by setting \$NOTES_DIRECTORY to your preferred path.
EOF
}

version() {
  local name=$(basename $0)
	cat <<EOF
$name $notes_version
EOF
}

main() {
    local ret=0
    local cmd=""

    # If no arguments passed, default to log.
    if [ -z "$1" ]; then
        log
        return 0
    fi

    case "$1" in
        "log"|"l" )
            cmd="log"
            ;;
        "new"|"n" )
            cmd="new_note"
            ;;
        "search"|"s" )
            cmd="search_filenames_and_contents"
            ;;
        "find"|"f" )
            cmd="find_notes"
            ;;
        "grep"|"g" )
            cmd="grep_notes"
            ;;
        "open"|"o" )
            cmd="handle_multiple_notes open"
            ;;
        --help | -help | -h )
            cmd="usage"
            ;;
        --version | -version )
            cmd="version"
            ;;
        * )
            local name=$(basename $0)
            printf "$1 is not a recognized $name command.\n\n"
            cmd="usage"
            ret=1
            ;;
    esac
    shift

    $cmd "$@"
    ret=$[$ret+$?]
    exit $ret
}
main "$@"
